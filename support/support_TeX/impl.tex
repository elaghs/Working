\section{Implementation}
\label{sec:impl}

\subsection{Lustre and IVCs}

\begin{figure}[t]
{\small
\begin{verbatim}
node main(x : int) returns (r : int; ok : bool);
let
  r = (0 -> pre r) + (if x > 0 then x else -x);
  ok = (r >= 0);
tel;
\end{verbatim}
}
  \caption{Example Lustre program}
  \label{fig:lustre-ex}
\end{figure}

Lustre is a synchronous dataflow language used as an input langauge
for various model checkers. An example Lustre program is shown in
Figure~\ref{fig:lustre-ex}. For our purposes, a Lustre program
consists of 1) some input variables, {\tt x} in the example, 2) some
output variables, {\tt r} and {\tt ok} in the example, and 3) an
equation for each output variable. A Lustre program runs over discrete
time steps. On each step, the input variables take on some values and
are used to compute values for the output variables on the same step.
In addition, equations may refer to the previous value of a variable
using the {\tt pre} operator. This operator is underspecified in the
initial step, so the arrow operator, {\tt ->}, is used to guard the
{\tt pre} operator. In the initial step the expression {\tt e1 -> e2}
reduces to {\tt e1}, and it reduces to {\tt e2} in all other steps.

We interpret a Lustre program as a model specification by considering
the behavior of the program under all possible input traces. Safety
properties over Lustre can then be expressed as Boolean output
variables in Lustre. A safety property holds if the corresponding
Boolean output variable is always true for all input traces. For
example, the program in Figure~\ref{fig:lustre-ex} represents an
integrator over the absolute value of the input variable. The output
variable {\tt ok} is a safety property of the system expressing that
the computed result is always non-negative. In this case, the property
is true.

It is easy to translate this interpretation of Lustre into the
traditional initial and transition relations. We will show this by
example using Figure~\ref{fig:lustre-ex}. First we introduce a new Boolean
variable $init$ into the state space to denote when the system is in
its initial step. Then we define,
\begin{align*}
  &I((x, r, \mathit{ok}, \mathit{init})) = \mathit{init} \\
  &T((x, r, \mathit{ok}, \mathit{init}), (x', r', \mathit{ok'},
  \mathit{init'})) = \\
  &\hspace{1cm} (r' = (\ite{init}{0}{r})) \land (\mathit{ok'} =
  (r' \geq 0)) \land \neg\mathit{init'}
\end{align*}
Each equation in the Lustre program is translated into a conjunct in
the transition relation. A safety property such as {\tt ok} is
translated into $\mathit{init} \lor \mathit{ok}$. Nested uses of arrow
and pre operators are handled by introducing new output variables for
nested expressions, though such details are unimportant for our
purposes.

\subsection{JKind}

JKind is an infinite-state model checker for safety properties. JKind
proves safety properties using multiple cooperative engines in
parallel including $k$-induction, property directed reachability
(PDR), and template-based lemma generation. JKind operates over
expressions in the theory of linear integer and real arithmetic. In
the back-end, JKind uses an SMT-solver such as Yices, Z3, CVC4,
MathSAT, or SMTInterpol.


\subsection{Older}

\mike{My thoughts on this section:}
\begin{itemize}
    \item introduce (and shrink) explanation of Lustre
    \item describe that $\widehat T$ is the set of equations in Lustre.
    \item describe what it means to remove an equation (to make valid Lustre, 
        turn assigned variable into input)?  I'm not sure this is necessary, and it 
        gets messy.
\end{itemize}

There are two important solver-based engines in \texttt{JKind} that can be considered as its primary proof-engines: \texttt{PDR} and \texttt{K-induction}. Current version of \texttt{JKind} has a new solver-based engine called \texttt{ReduceSupport},
which is an implementation of Algorithm~\ref{alg:set-of-support}.
One major goal of our experiments was to evaluate the minimality of the support sets computed by \texttt{ReduceSupport}.
To do so, we needed to compare the output of our algorithm with another algorithm
which computes a truly minimal support set, i.e. Algorithm~\ref{alg:naive}. Hence, we extended \texttt{JKind}
with another support computing tool, called \texttt{JSupport}, which is an implementation of Algorithm~\ref{alg:naive}.

As described in~\ref{subsec:jkind}, \texttt{JKind} accepts LUS models for verification.
Such models are made of a set of nodes each of which embodies a set of inputs, outputs, equations, assertions, and properties. For each property, each equation can be considered as an element of an initial set called \textit{\%SUPPORT}. Given initial support set $S$ for property $P$, \texttt{ReduceSupport} finds which of the items in $S$ are necessary to prove $P$. The output of this computation will be a (closely) minimal set of support for $P$. In light of this process, the extended version of \texttt{JKind} we used for the experiments includes:

\begin{itemize}
    \item an algorithm to compute a truly minimal set of support, i.e. \texttt{JSupport}.
    \item given a LUS model, a static crawler which automatically marks all equations of a node in the initial support set of a property.
    \item some trackers that measure the verification time with/ without support computation.
    \item some minor changes in the XML writers.
\end{itemize}


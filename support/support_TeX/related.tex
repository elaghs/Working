\section{Related work}
\label{sec:related}

In recent years, extraction of Minimally Unsatisfiable Subformulas
(MUSes) has been the focus of a lot of research work
\cite{marques2010minimal, belov2012towards, ryvchin2011faster,
  belov2012computing, nadel2010boosting}. Although algorithms proposed
by such work can handle very large problems, computing MUSes is still
very resource-intensive task. While some work aimed to provide a set
of minimal unsatisfiable formulae, they define minimality in a way
that given a set of clauses $\mathbb{M}$, removing every member of
$\mathbb{M}$ makes it satisfiable \cite{belov2012computing}. Such
algorithms are often compared with each other. In this work, we
compare a regular computation of minimal unsat-core against
\emph{minimum} unsat-core extraction. In addition, our focus is not to
provide a novel way of computing minimal unsat-core. Instead, we make
use of MUSes to efficiently compute a set of support of the model
necessary for inductive proofs.

Gupta et al. \cite{gupta2003iterative} and McMillan and Amla
\cite{mcmillan2003automatic} introduced the use of unsatisfiable cores
in proof-based abstraction engines. Their goal is to shrink the
abstraction size by omitting the parts of the design that are
irrelevant to the proof of the property under verification. However,
\cite{gupta2003iterative, mcmillan2003automatic} do not consider core
minimization. In another work \cite{nadel2010boosting}, Nadel
discusses a number of applications of MUSes extraction in formal
verification. To our knowledge, none of the existing work has used
MUSes to provide support information that explains the correctness of
proofs provided by different inductive techniques including PDR and
k-induction.

Torlak et al. in \cite{torlak2008finding} proposed an algorithm for
finding MUSes of declarative specification implemented for the Alloy
language. Alloy is a framework for describing high-level design of
various systems, whose analyzer is a fully automatic constraint
solver. Constraints are translated into propositional logic solved by
a SAT solver; hence, the analysis considers only a finite number of
values for each type. For this reason, even for a set of simple
constraints, the analyzer is never able to prove the correctness of a
property. Another major difference between \cite{torlak2008finding}
and ours is that we extract UNSAT cores from an inductive proof over a
sequential model involving lemmas. Besides, Alloy mostly works based
on SAT solving, instead of SMT solving. In our implementation, JKind
supports a variety of powerful SMT solvers (such as Z3, Yices, Yices2,
etc.).

\begin{itemize}
    \item MUS's : checked
    \item Work on Alloy: checked
    \item Work that Teme pointed us to : will be added
    \item Anything else Elaheh has found : \%60 checked
\end{itemize}


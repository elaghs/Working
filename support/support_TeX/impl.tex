\section{Implementation}
\label{sec:impl}

\mike{My thoughts on this section:}
\begin{itemize}
    \item introduce (and shrink) explanation of Lustre
    \item describe that $\widehat T$ is the set of equations in Lustre.
    \item describe what it means to remove an equation (to make valid Lustre, 
        turn assigned variable into input)?  I'm not sure this is necessary, and it 
        gets messy.
\end{itemize}

There are two important solver-based engines in \texttt{JKind} that can be considered as its primary proof-engines: \texttt{PDR} and \texttt{K-induction}. Current version of \texttt{JKind} has a new solver-based engine called \texttt{ReduceSupport},
which is an implementation of Algorithm~\ref{alg:set-of-support}.
One major goal of our experiments was to evaluate the minimality of the support sets computed by \texttt{ReduceSupport}.
To do so, we needed to compare the output of our algorithm with another algorithm
which computes a truly minimal support set, i.e. Algorithm~\ref{alg:naive}. Hence, we extended \texttt{JKind}
with another support computing tool, called \texttt{JSupport}, which is an implementation of Algorithm~\ref{alg:naive}.

As described in~\ref{subsec:jkind}, \texttt{JKind} accepts LUS models for verification.
Such models are made of a set of nodes each of which embodies a set of inputs, outputs, equations, assertions, and properties. For each property, each equation can be considered as an element of an initial set called \textit{\%SUPPORT}. Given initial support set $S$ for property $P$, \texttt{ReduceSupport} finds which of the items in $S$ are necessary to prove $P$. The output of this computation will be a (closely) minimal set of support for $P$. In light of this process, the extended version of \texttt{JKind} we used for the experiments includes:

\begin{itemize}
    \item an algorithm to compute a truly minimal set of support, i.e. \texttt{JSupport}.
    \item given a LUS model, a static crawler which automatically marks all equations of a node in the initial support set of a property.
    \item some trackers that measure the verification time with/ without support computation.
    \item some minor changes in the XML writers.
\end{itemize}


\subsection{JKind and Lustre}
\label{subsec:jkind}

JKind is an infinite-state model checker for safety properties. JKind
proves safety properties using multiple cooperative engines in
parallel including $k$-induction, property directed reachability
(PDR), and template-based lemma generation. JKind operates over
expressions in the theory of linear integer and real arithmetic. In
the back-end, JKind uses an SMT-solver such as Yices, Z3, CVC4,
MathSAT, or SMTInterpol.

\begin{figure}[t]
\begin{verbatim}
node main(x : int) returns (r : int; ok : bool);
let
  r = (0 -> pre r) + (if x > 0 then x else -x);
  ok = (r >= 0);
tel;
\end{verbatim}
  \caption{Example Lustre program}
  \label{fig:lustre-ex}
\end{figure}

The input language to JKind is Lustre, a synchronous dataflow language.
An example Lustre program is shown in Figure~\ref{fig:lustre-ex}. For
our purposes, a Lustre program consists of 1) some input variables,
{\tt x} in the example, 2) some output variables, {\tt r} and {\tt ok}
in the example, and 3) an equation for each output variable. A Lustre
program runs over discrete time steps. On each step, the input
variables take on some values and are used to compute values for the
output variables on the same step. In addition, equations may refer to
the previous value of a variable using the {\tt pre} operator. This
operator is undefined in the initial step, so the arrow operator, {\tt
  ->}, is used to guard such the {\tt pre} operator. In the initial
step the expression {\tt e1 -> e2} reduces to {\tt e1}, and it
reduces to {\tt e2} in all other steps.

We interpret a Lustre program as a model specification by considering
the behavior of the program under all possible input traces. Safety
properties over Lustre can then be expressed as Boolean output
variables in Lustre. A safety property holds if the corresponding
Boolean output variable is always true for all input traces. For
example, the program in Figure~\ref{fig:lustre-ex} represents an
integrator over the absolute value of the input variable. The output
variable {\tt ok} is a safety property of the system expressing that
the computed result is always non-negative. In this case, the property
is true.

It is easy to translate this interpretation of Lustre into the
traditional initial and transition relations. We will show this by
example using Figure~\ref{fig:lustre-ex}. First we introduce a new Boolean
variable $init$ into the state space to denote when the system is in
its initial step. Then we define,
\begin{align*}
  &I((x, r, \mathit{ok}, \mathit{init})) = \mathit{init} \\
  &T((x, r, \mathit{ok}, \mathit{init}), (x', r', \mathit{ok'},
  \mathit{init'})) = \\
  &\hspace{1cm} (r' = (\ite{init}{0}{r})) \land (\mathit{ok'} =
  (r' \geq 0)) \land \neg\mathit{init'}
\end{align*}
Each equation in the Lustre program is translated into a conjunct in
the transition relation. A safety property such as {\tt ok} is
translated into $\mathit{init} \lor \mathit{ok}$. Nested uses of arrow
and pre operators are handled by introducing new output variables for
nested expressions, though such details are unimportant for our
purposes.

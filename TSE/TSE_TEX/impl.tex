\section{Implementation}
\label{sec:impl}

We have implemented all of the inductive validity core algorithms from the previous section in an industrial model checker called \texttt{JKind} ~\cite{jkind},
which verifies safety properties of infinite-state synchronous systems.
It accepts Lustre programs \cite{Halbwachs91:lustre} as input.  The translation of Lustre
into a symbolic transition system in \texttt{JKind} is straightforward and is similar to what is described
in~\cite{Hagen08:FMCAD}.
Verification is supported by multiple ``proof engines'' that execute in parallel, including $k$-induction,
property directed reachability (PDR), and lemma generation engines that attempt to prove
multiple properties in parallel.  To implement the engines,
\texttt{JKind} emits SMT problems using the theories of linear integer and real arithmetic.  \texttt{JKind} supports the
%I remove citations to save some space in the end
%------------------
%\texttt{Z3}~\cite{DeMoura08:z3},
%\texttt{Yices}~\cite{Dutertre06:yices}, \texttt{MathSAT}~\cite{Cimatti2013:MathSAT},
%\texttt{SMTInterpol}~\cite{Christ2012:SMTInterpol}, and \texttt{CVC4} \cite{barrett2011cvc4}
%----------------------------------------------------------------
\texttt{Z3}, \texttt{Yices}, \texttt{MathSAT}, \texttt{SMTInterpol}, and \texttt{CVC4} SMT solvers as back-ends.  When a property is
proved and IVC generation is enabled, an additional parallel engine
executes one of the {\ucalg, \bfalg, \ucbfalg}~algorithms \cite{Ghass16} to generate an (approximately) minimal IVC.
%
To implement the \aivcalg\ procedure, we have extended \texttt{JKind} with a new engine that implements Algorithm \ref{alg:aivc}.
We use the \texttt{JKind} IVC generation engine to implement the \getivc\ procedure in  Algorithm \ref{alg:aivc}.
%It worth mentioning that we could have employed the \ucbfalg ~algorithm for this purpose as well.
%One might say that since \ucbfalg ~guarantees minimality, it would help to the \aivcalg ~algorithm terminate more quickly.
%However, as we will show in the experiments, on the one hand, the \ucbfalg ~algorithm is very expensive. On the other hand, the \ucalg ~algorithm is not only fast, but it also generates \ivc s that are
%quite close to the \mivc s computed by \ucbfalg.

As previously discussed, one issue that needs to
be handled in any implementation of the \ucalg, \ucbfalg, and \aivcalg~algorithms involves the undecidability of the model checking problem;
in each iteration of Algorithms~\ref{alg:naive} and~\ref{alg:aivc}, we attempt to prove the property with a subset $S$ of the original model.  Although we know that $(I, T) \vdash P$, from Theorem~\ref{thm:minimal-hard}, the problem of determining whether or not any $S \subset T$ is adequate is undecidable.
%
Therefore, we have to set timeouts for the model checking algorithm for each iteration of the \aivcalg\ procedure.
In our implementation, we measure the time required to prove the property over the original model (\emph{proof-time}), and the time required to calculate the first
(approximate) IVC using \ucalg\ (\emph{\ucalg-time}).
The timeout we set for each iteration of the \ucbfalg\ and \aivcalg\ algorithms is ($30$ sec  $+\ 5\ \times$ (\emph{proof-time} $+$ \emph{\ucalg-time})).

If the \texttt{while} loop times out for $S$ in line 8 of Algorithm~\ref{alg:aivc},
we treat $S$ as an \emph{inadequate} set to ensure that all results support a proof.
In this case, line 13 will prune off $S$ and all
its subsets from the search space.  Since the timeout is used by both the brute-force
algorithm and the \aivcalg\ algorithm, minimality is only guaranteed if there
are no timeouts.  If a timeout occurs during computation, we report a warning to the user that our results are not guaranteed to be minimal.
It is important to note that by increasing the timeout, it is possible that
in some cases smaller IVCs can be generated, but the general problem will remain due
to the undecidability of the model checking problem.




%The source code is publicly available on \cite{mygit}.
%This section points out some technical issues in the implementation.
%
%We have extended \texttt{JKind} with a new engine that
% implements Algorithm \ref{alg:aivc}.
% First a property is proved and a single IVC set $S$ is computed
% by the IVC generation engine. Then, the set $S$ is sent to our engine.
% For efficiency, instead of initializing $map$ with $\top$,
% we initialize $map$ with $\bigvee_{T_{i}\in S} \neg {\actlit (T_i)}$,
% which prunes off set $S$ and all its supersets from $\mathcal{P}(T)$ at the beginning of the algorithm. If $S$ is minimal, then chances are a large
% subset of  $\mathcal{P}(T)$ is marked as explored even before
% the algorithm starts the search.


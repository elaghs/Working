\section{Set of Support}
\label{sec:support}

Given a transition system which satisfies a safety property $P$, we
want to know which parts of the system are necessary for satisfying
the safety property. One possible way of asking this is, ``What is the
most general version of this transition system that still satisfies
the property?'' It turns out this has a very uninteresting answer. The
most general system is $I(s) = P(s)$ and $T(s, s') = P(s')$, i.e., you
start in any state satisfying the property and can transition to any
state that still satisfies the property. This answer gives no insight
into the original system because it has no connection to the original
system. In this section we introduce the notion of {\em set of
  support} which looks generalizing the original transition system
while preserving a safety property.

In order to talk about generalizing a transition system, we assume the
transition relation of the system has the structure of a top-level
conjunction. This assumption gives us a structure that we can easily
manipulate as we generalize the system. Moreover, we will see later
that this restriction can be effectively relaxed by introducing new
variables which act like activation literals for pieces of the
transition relation. For easy of notation we will write the top-level
of the transition system $T_1(s, s') \land \cdots \land T_n(s, s')$ as
just $T_1 \land \cdots \land T_n$ or even $\bigwedge T$ where $T =
\{T_1, \ldots, T_n\}$. We now define our notion of generalization for
transition systems.

\marginpar{We may want to simplify notation and allow $(I, T)$ where
  $T$ is a set to mean the same as $(I, \bigwedge T)$.}

\begin{definition}[Set of support]
  \label{def:set-of-support}
  Let $(I, \bigwedge T)$ be a transition system and let $P$ be a
  safety property with $(I, \bigwedge T)\vdash P$. We say $S \subseteq
  T$ is a {\em set of support} for $(I, \bigwedge T)\vdash P$ iff $(I,
  \bigwedge S) \vdash P$. When $I$, $T$, and $P$ can be inferred from
  context we will simply say $S$ is a set of support.
\end{definition}

\begin{definition}[Minimal Set of support]
  \label{def:minimal-set-of-support}
  A set of support $S$ for $(I, \bigwedge T)\vdash P$ is minimal iff
  there does not exist $M \subset S$ such that $M$ is a set of support
  for $(I, \bigwedge T)\vdash P$.
\end{definition}

\begin{lemma}
  \label{lem:set-of-support-monotonic}
  Let $(I, \bigwedge T)$ be a transition system and let $P$ be a
  safety property with $(I, \bigwedge T)\vdash P$. Let $S_1 \subseteq
  S_2 \subseteq T$. If $S_1$ is a set of support for $(I, \bigwedge
  T)\vdash P$ then $S_2$ is a set of support for $(I, \bigwedge T)\vdash P$.
\end{lemma}
\begin{proof}
  From $S_1 \subseteq S_2$ we have $\forall s, s'.~ \bigwedge
  S_1(s,s') \Rightarrow \bigwedge S_2(s, s')$. Thus the reachable
  states of $(I, \bigwedge S_1)$ are a subset of the reachable states
  of $(I, \bigwedge S_2)$. \qed
\end{proof}

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$(I, \bigwedge T)\vdash P$}
  \Output{Minimal set of support for $(I, \bigwedge T)\vdash P$}
  \BlankLine
  $S \leftarrow T$ \\
  \For{$x \in S$} {
    \If{$(I, \bigwedge (S\setminus\{x\})) \vdash P$}{
      $S \leftarrow S\setminus \{x\}$
    }
  }
  \Return{S}
\caption{Simple algorithm for computing a minimal set of support}
\label{alg:naive}
\end{algorithm}

This lemma gives us a simple, but inefficient algorithm for computing
a minimal set of support, Algorithm~\ref{alg:naive}
 The resulting set
of this algorithm is obviously a set of support for $(I, \bigwedge
T)\vdash P$. Minimality requires more work.

\begin{lemma}
  The result of Algorithm~\ref{alg:naive} is a minimal set of support
  for $(I, \bigwedge T)\vdash P$.
\end{lemma}
\begin{proof}
  Let the result be $R$. Suppose towards contradiction that $M \subset
  R$ is a set of support. Take $x \in R\setminus M$. Since $x \in R$
  it must be that during the algorithm $(I,
  \bigwedge(S\setminus\{x\})\vdash P$ is not true for some set $S$
  where $R \subseteq S$. We have $M \subset R \subseteq S$ and
  $x\not\in M$, thus $M \subseteq S\setminus \{x\}$. Since $M$ is a
  set of support, Lemma~\ref{lem:set-of-support-monotonic} says that
  $S\setminus \{x\}$ is a set of support, and so $(I, \bigwedge
  (S\setminus\{x\}))\vdash P$. This is a contradiction, thus $R$ must
  be minimal.
\end{proof}

This algorithm has two problems in practice. First, checking if a
safety property holds on a system is undecidable in general thus the
algorithm may never terminate. This may be even when the safety
problem is easily provable over the original Lustre specification.
Second, this algorithm is very inefficient since it requires
attempting to re-prove the property multiple times.

The key to a more efficient algorithm is to make better use of the
information that comes out of checking that $P$ holds on a system $(I,
\bigwedge T)$. Thus we suppose that we know something stronger: $P$
with invariants $Q_1, \ldots, Q_n$ is $k$-inductive for $(I, \bigwedge
T)$. This gives us the broad structure of a proof for $P$ which allows
us to reconstruct the proof over a modified transition system.
However, the proof itself may be unnecessarily large. If $k$ larger
than needed reconstructing the proof is needlessly expensive. If more
invariants are used than needed, additional parts of the transition system
may become part of the set of support making the result less precise.
Thus we should first reduce these elements of the proof before trying
to find a set of support. This is the basis for
Algorithm~\ref{alg:support-top}.

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$P$ with $Q_1, \ldots, Q_n$ is $k$-inductive for $(I,
    \bigwedge T)$}
  \Output{Nearly minimal set of support for $(I, \bigwedge T)\vdash P$}
  \BlankLine
  $k \leftarrow \mbox{compute minimal value of $k$}$ \\
  $\{R_1, \ldots, R_m\} \leftarrow \mbox{reduce set of invariants
    $\{Q_1, \ldots, Q_n\}$} \\
  $S \leftarrow \mbox{compute minimal $S\subseteq T$ such that $P \land R_1
    \land \cdots \land R_m$ is $k$-inductive for $(I, \bigwedge S)$}$ \\
  \Return{S}
\caption{Efficient algorithm for computing a nearly minimal set of support}
\label{alg:support-top}
\end{algorithm}

The first step in Algorithm~\ref{alg:support-top} is to minimize the
value of $k$ such that $P$ with $Q_1, \ldots, Q_n$ is $k$-inductive
for $(I, \bigwedge T)$. That is, we want to find $k'$ such that
$\widehat{P} = P \land Q_1 \land \cdots \land Q_n$ is $k'$-inductive
for $(I, \bigwedge T)$. Naively this would require checking the base
case formulas and the inductive case formulas for $k'$-induction.
However, we are searching for $k' \leq k$ so we know that the base
case formulas will already hold since $\widehat{P}$ is $k$-inductive.
Thus it sufficies to check just the inductive step formula. We can do
this by checking the inductive step formula starting at $k' = 0$ and
increasing up to potentially $k$.

The second step in Algorithm~\ref{alg:support-top} is to reduce the
set of invariants such that $P$ together with the invariants is
$k$-inductive for $(I, \bigwedge T)$. First, note that it is not
effective to naively try to remove the invariants one by one. It may
be that two invariants mutually depend on each other while still being
unnecessary towards proving $P$. Also, it is not effective to start
with no invariants and try adding them since $P$ most likely requires
some of the invariants, but we do not know which. Instead, we take a
hybrid approach.

TODO: Explaining this requires something like UNSAT cores. We need to
add that into our formalism.

Unfortuently, we do not guaranteed minimal set of invariants in step 2
of Algorithm~\ref{alg:support-top}. This means the result of algorithm
may not be a minimal support. In Section~\ref{sec:exprm} we study how
close the algorithm comes to minimality in practice.

TODO: Show how our conjunction restriction can be used with activation
literals to target any part of a transition system?

TODO: Rewrite background based on what we use in this section

\newcommand{\bq}{\textsc{BaseQuery}\xspace}
\newcommand{\iq}{\textsc{InductiveQuery}\xspace}
\newcommand{\fq}{\textsc{FullQuery}\xspace}

\newcommand{\mink}{\textsc{MinimizeK}\xspace}
\newcommand{\reduceinv}{\textsc{ReduceInvariants}\xspace}
\newcommand{\sos}{\textsc{SetOfSupport}\xspace}

\newcommand{\checksat}{\textsc{CheckSat}\xspace}
\newcommand{\unsatcore}{\textsc{UnsatCore}\xspace}
\newcommand{\unsat}{\textsc{UNSAT}\xspace}
\newcommand{\sat}{\textsc{SAT}\xspace}

\begin{figure}
\begin{align*}
  &\bq_1(I, T, P) \equiv \forall s_0.~ I(s_0) \Rightarrow P(s_0) \\
%%%
  &\bq_{k+1}(I, T, P) \equiv \bq_k(I, T, P) \land~ \\
%
  &\hspace{10pt}\left(\forall s_0, \ldots, s_k.~ I(s_0) \land T(s_0,
  s_1) \land \cdots \land T(s_{k-1}, s_k) \Rightarrow P(s_k)\right)
  \\[5pt]
%%%
  &\iq_k(T, Q, P) \equiv \\
%
  &\hspace{10pt}\left(\forall s_0, \ldots, s_k.~ Q(s_0) \land T(s_0,
  s_1) \land \cdots \land Q(s_{k-1}) \land T(s_{k-1}, s_k) \Rightarrow
  P(s_k)\right) \\[5pt]
%%%
  &\fq_k(I, T, P) \equiv \bq_k(I, T, P) \land \iq_k(T, P, P)
\end{align*}
\caption{$k$-induction queries}
\label{fig:queries}
\end{figure}

\begin{algorithm}
  $k \leftarrow 1$ \\
  \While{$true$} {
    \If{$\checksat(\neg\iq_k(T, P, P)) = \unsat$} {
      \Return{k} \\
    }
    $k \leftarrow k + 1$ \\
  }
\caption{$\mink(T, P)$}
\label{alg:minimize-k}
\end{algorithm}

\begin{algorithm}
  $R \leftarrow \{P\}$ \\
  Create activation literals $a_1, \ldots, a_n$ \\
  $C \leftarrow \{a_1 \Rightarrow Q_1, \ldots, a_n \Rightarrow Q_n\}$ \\
  \While{$true$} {
    $\checksat(\neg\iq_k(T, \bigwedge C, \bigwedge R))$ \\
    \If{$\unsatcore() = \emptyset$}{
      \Return{R}
    }
    \For{$a_i \in \unsatcore()$}{
      $R \leftarrow R \cup \{Q_i\}$ \\
      $C \leftarrow C \setminus \{a_i \Rightarrow Q_i\}$ \\
    }
  }
\caption{$\reduceinv_k(T, \{Q_1, \ldots, Q_n\}, P)$}
\label{alg:reduce-invariants}
\end{algorithm}

\begin{algorithm}
  Create activation literals $a_1, \ldots, a_n$ \\
  $T \leftarrow (a_1 \Rightarrow T_1) \land \cdots \land (a_n \Rightarrow T_n)$ \\
  $\checksat(\neg\fq_k(I, T, P))$ \\
  $R \leftarrow \emptyset$
  \For{$a_i \in \unsatcore()$}{
    $R \leftarrow R \cup \{T_i\}$
  }
  \Return{R}
  }
\caption{$\sos_k(I, T_1 \land \ldots \land T_n, P)$}
\label{alg:set-of-support}
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main.tex"
%%% End

%%  LocalWords:  Lustre iff TODO invariants Minimality

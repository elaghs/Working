\section{Method}
\label{sec:allivcs}

\newcommand{\getivc}{\textsc{GetIVC}}
\newcommand{\getmodel}{\textsc{GetLiteralsFromMaxModel}}
\newcommand{\aivcalg}{\texttt{\small{All\_IVCs}}}
\newcommand{\blockup}{\textsc{BlockUp}}
\newcommand{\blockdown}{\textsc{BlockDown}}
\newcommand{\mis}{\textsc{MIS}}
\newcommand{\mcs}{\textsc{MCS}}

\newcommand{\checksat}{\textsc{CheckSat}}
\newcommand{\isadeq}{\textsc{CheckAdq}}
\newcommand{\actlit}{\textsc{ActLit}}
\newcommand{\unsatcore}{\textsc{UnsatCore}\xspace}
\newcommand{\unsat}{\texttt{UNSAT}\xspace}
\newcommand{\sat}{\texttt{SAT}\xspace}

Considering the definition of an IVC, a brute-force technique for enumerating all IVCs would be the same as exploring the power set of $T$ (denoted by $ \mathcal{P}(T) $).
Basically, the algorithm needs to explore the provability of a
given property by any subset of $T$, which would be computationally expensive.
However, this section proposes a complete
enumeration algorithm that only needs to explore a (small) portion of $\mathcal{P}(T)$
in order to compute $AIVC$. To this end, we begin with introducing several additional notions and definitions, most of which are inspired by the MUS enumeration technique proposed in \cite{marco2016fast}.

\begin{definition} {\emph{Adequacy:}}
\label{def:adeq}
Given $(I, T) \vdash P$, for every $S \in \mathcal{P}(T)$, we have either $(I, S) \vdash P$ or $(I, S) \nvdash P$. In the former case, we say $S$ is \textbf{adequate} for $P$; in the latter, we say that $S$ is \textbf{inadequate} for the proof of $P$.
\end{definition}

Obviously, for every inadequate set $S \subset T$, there is some set $C \subset T$ such that $S \cup C$ is adequate; we refer to such set $C$ as a \emph{correction set} for $S$. Furthermore, considering the definition of $IVC$, every set $S \in AIVC (P)$ is a \emph{minimal} adequate set meaning  that $\nexists S' \subset S. (I, S') \vdash P$. 

\begin{definition}{\emph{Maximal Inadequate Set (MIS):}}
  \label{def:mis}
  $S \subset T$ for $(I, T) \vdash P$ is a Maximal Inadequate Set (MIS) \emph{iff}
  $(I, S) \nvdash P$ and $\forall T_i \in T\setminus S.~ (I, S\cup\{T_i\}) \vdash P$.
\end{definition}

%\begin{definition}{\emph{Minimal Correction Set (MCS):}}
%  \label{def:mcs}
%  $S \subset T$ for $(I, T) \vdash P$ is a Minimal Correction Set (MCS) iff
%  $(I, T \setminus S) \nvdash P$ and $\forall T_i \in S.~ (I, (T \setminus S)\cup \{T_i\}) \vdash P$.
%\end{definition}

%It should be mentioned that minimality and maximality are about minimum or maximum cardinality subsets.
%Note that $MCS$ is more of syntactic sugar that specifies sets that can also be specified by $MIS$; i.e. for any $MIS$ of $T$, there is a corresponding $MCS$ such that adding any element of that $MCS$ to the $MIS$, makes the property provable by the $MIS$.
%And, that's why it is called the ``minimal correction'' set.

\begin{lemma}
\label{lem:adeq}
For $(I, T) \vdash P$, if $S \subset T$ is adequate for property $P$, then all of its supersets are adequate for $P$ as well:
\allowbreak $$\forall S_1 \subset S_2 \subset T.~ (I, S_1) \vdash P \Rightarrow (I, S_2) \vdash P$$
\end{lemma}
\begin{proof}
From $S_1 \subseteq S_2$ we have $S_2 \Rightarrow S_1$. Thus the
  reachable states of $(I, S_2)$ are a subset of the reachable states
  of $(I, S_1)$.
\end{proof}

\begin{corollary}
\label{lem:inadeq}
For $(I, T) \vdash P$, if a given subset $S$ is inadequate, then all of its subsets are inadequate as well:
\allowbreak $$\forall S_1 \subset S_2 \subset T.~ (I, S_2) \nvdash P \Rightarrow (I, S_1) \nvdash P$$
\end{corollary}
\begin{proof}
  Immediate from Lemma \ref{lem:adeq}.
\end{proof}
%\begin{proof}
%Given the fact that $(I, T) \vdash P$ and $S_2$ is inadequate,
%there is a correction set $C \subseteq (T\setminus S_2)$ such that
%$C \cup S_2$ is adequate, which implies every $S' \subseteq (T \setminus C)$ is inadequate.
%So, since $S_1 \subset S_2 \subseteq (T \setminus C)$, set $S_1$ is also inadequate.
%\end{proof}

%\begin{corollary}
%$\forall S \in AIVC(P)$, S is a minimal adequate set for $P$.
%\end{corollary}
%\begin{proof}
%  Immediate from the definitions of $IVC$ and $AIVC$, and Lemma \ref{lem:adeq}.
%\end{proof}

The basic idea behind an algorithm for computing $AIVC(P)$ is the same as exploration of $\mathcal{P}(T)$ determining whether or not every set $S \in \mathcal{P}(T)$ is adequate for $P$.
At first, all the sets in $\mathcal{P}(T)$ are \emph{unexplored}. When the adequacy of a set $S \in \mathcal{P}(T)$ is determined/known, we consider $S$ as \emph{explored}.
In order to choose an unexplored set and keep track of which parts of the the power set
have been explored, we use a Boolean expression $map$, which is
in conjunctive normal form (CNF) and built gradually as the algorithm proceeds.
With the help of $map$, an unexplored set $S$ is selected. After processing $S$,
formula $map$ is updated such that marks $S$ as \emph{explored}.
As $map$ is updated, it guides our exploration algorithm for $AIVC$.
In other words, $map$ represents the \emph{search space} needed to be explored for finding all IVCs.

More precisely, given $T$ with $n$ top-level conjuncts,
we define an ordered
set of activation literals $\mathcal{A} = \{a_1...a_n\}$, where every $a_i$ is of type of Boolean. Function $\actlit : T \rightarrow \mathcal{A}$
is a bijection function assigning every $T_i \in T$ to an $a_i \in \mathcal{A}$ and vice versa.
Then, a $map$ for $AIVC(P)$ is a CNF formula built over the elements of $\mathcal{A}$ such that:
\begin{itemize}
  \item Initially $map$ is $\top$ interpreted as the fact that the whole $\mathcal{P}(T)$ is unexplored.
  \item When $map$ is satisfiable, a model of it is a set
  $M \in \mathcal{P}(\mathcal{A})$.
  \item Every model $M$ of $map$ corresponds to a set $S \in \mathcal{P}(T)$ such that
$S = \bigcup_{a_i \in M} \actlit ^{-1} (a_i)$ and $M = \bigcup_{T_i \in S} \actlit(T_i)$.
  \item For every explored set $S \in \mathcal{P}(T)$:
  \begin{itemize}
    \item if $S$ is adequate for $P$, then $map$ contains a clause $\bigvee_{T_{i}\in S} \neg {\actlit (T_i)}$. Note that, according to Lemma \ref{lem:adeq}, such a clause automatically marks every superset of $S$ as explored, which shrinks our search space. So, it is said those supersets are \emph{dominated} by $S$.
    \item if $S$ is inadequate for $P$, then $map$ contains a clause $\bigvee_{T_{i}\in (T \setminus S)} \actlit (T_i)$. Note that, according to Corollary \ref{lem:inadeq}, such a clause automatically makes every subset of $S$ as explored, which prunes the search space. So, it is said those subsets are \emph{dominated} by $S$.
  \end{itemize}
\end{itemize}


\begin{lemma}
\label{lem:map:sound}
When $map$ is satisfiable with model $M$, set $S = \bigcup_{a_i \in M} \actlit ^{-1} (a_i)$ is not subset (superset) of any
inadequate (adequate) explored sets of $\mathcal{P}(T)$.
\end{lemma}
\begin{proof}
Proof by contradiction. Case 1: Suppose there is an adequate set $Ex \subset S$ that has been already explored. Therefore, according to the definition, $map$ contains a clause $C = \bigvee_{T_{i}\in Ex} \neg {\actlit (T_i)}$, and since $Ex \subset S$, it is impossible for the model $M = \bigcup_{T_i \in S} \actlit (T_i)$ to satisfy $C$; hence, the assumption is false.

Case 2: Suppose there is an inadequate set $Ex$ such that $S \subset Ex$ and $Ex$ has been already explored. Therefore, according to the definition, $map$ contains a clause $C = \bigvee_{T_{i}\in (T \setminus S)} \actlit (T_i)$, and since $S \subset Ex$, it is impossible for the model $M = \bigcup_{T_i \in S} \actlit (T_i)$ to satisfy $C$; so, the assumption is false.

From Case 1 and Case 2, there is no model of $map$ whose corresponding set in $\mathcal{P}(T)$ is the subset (superset) of any inadequate (adequate) explored sets.
\end{proof}


\begin{lemma}
\label{lem:map:comp}
For $(I, T) \vdash P$, $map$ is unsatisfiable \emph{iff} all $S \in AIVC(P)$ and all $MIS$es of $T$ (and thus every $S \in \mathcal{P}(T)$) have been explored.
\end{lemma}
\begin{proof}
As with any CNF formula, $map$ is unsatisfiable \emph{iff} every complete assignment falsifies at least one of its clauses. Clauses in $map$ have special structure;
according to definition, every clause contains a set of either entirely negative literals or entirely positive; when a set $S$ corresponding to a model $M$ of map is explored, if $S$ is adequate, it means that it contains necessary elements of $T$ to prove $P$, which
are added to $map$ as a new clause containing \emph{negative} activation literals of $S$. However, when
$S$ is inadequate, it means that $S$ lacks a correction set $C$ of $T$ so to prove $P$.
And, in this case, a new clause containing \emph{positive} activation literals of $C$ is added to $map$. Generally, similar to the elements of adequate sets, elements of correction sets are also essential part of some proof, which means eventually, negative literals added from adequate sets will have their own  positive form added from the correction sets (and vice versa).
Therefore, every complete assignment falsifies at least one clause in $map$ \emph{iff} every
member of $\mathcal{P}(T)$ is dominated by some adequate or inadequate set.
And, considering the definitions of $IVC$ and $MIS$,  every member of $\mathcal{P}(T)$ is dominated by some set \emph{iff} all $IVC$s and $MIS$es have been explored. According to definition of $map$, when all $IVC$s and $MIS$es are covered, every $S \in \mathcal{P}(T)$ will be covered as well.
\end{proof}

%\begin{lemma}
%\label{lem:map:cc}
%For $(I, T) \vdash P$, $map$ is unsatisfiable \emph{iff} every $S \in \mathcal{P}(T)$ has been explored.
%\end{lemma}
%\begin{proof}
%Immediate from Lemma \ref{lem:map:comp}.
%\end{proof}


Algorithm~\ref{alg:aivc} shows the process of capturing all IVCs, which are kept in set $A$.
In line 2, we create the set of activation literals used by function \actlit . Line 3 initializes $map$ with $\top$ over the set of literals we have. The main loop of state exploration starts at line 4 and continues until $map$ becomes \unsat that means all the IVCs have been found. We assume we have a function \checksat ~that determines if an existentially quantified formula  is satisfiable or not\footnote{We assume readers are familiar with the Boolean satisfiability problem, which is the problem of determining whether there exists an assignment that satisfies a given propositional formula. For more information, refer to \cite{cook1971complexity}.}.
%$$\checksat : Boolean \rightarrow \{ true~(\sat), false~(\unsat) \}$$
As long as $map$ is satisfiable, the algorithm computes a \emph{maximal} \sat model for it (line 5). A maximal SAT model is a model with as many $true$ assignment as possible without violating a clause; this problem, known as MaxSAT, has been well studied in the literature \cite{cimatti2013modular, davies2011solving, morgado2013iterative}, so we assume there is a method by which we are able to have a maximal model of $map$.
Line 6 extracts a set $M \in \mathcal{P} (\mathcal{A})$ of literals assigned to $true$ in the model.
Then, we need to obtain the corresponding set of $M$ in $\mathcal{P}(T)$, which is done with function $\actlit ^{-1}$ in line 7. Note that such a set will be a $MIS$ that all its supersets have already been explored. We also assume there is a function \isadeq ~that checks whether or not $P$ is provable by a given subset of $T$. Using this function, the adequacy of $M$ is determined in line 8; if $M$ is adequate, an IVC  is computed by \getivc ~and added to set $A$ (line 10).\footnote{Note that \isadeq ~can be any method that verifies a safety property, such as K-induction. As for \getivc , Ghassabani et al. proposed an efficient algorithm for computing a single IVC in \cite{Ghass16} that can be used for the \getivc ~module.} In this case $map$ is constrained by a new clause in a way described before and shown in line 11. However, in case that $M$ is inadequate, $map$ is constrained by the corresponding literals from the correction set of $M$ (i.e. $T \setminus M$) in lines (12-13).

\begin{algorithm}[t]
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$(I, T) \vdash P$}
  \Output{$AIVC (P)$}
  \BlankLine
  $A \leftarrow \varnothing$\\
  Create activation literals $\{a_1, \ldots, a_n\}$ \\
 % $map \leftarrow true$ \\
  $map \leftarrow \top$ \\
 % $L \leftarrow \varnothing$ \\
  \BlankLine

  \While{$\checksat (map)$} {
    $model \leftarrow $ build a maximal model of $map$ \\
    $M \leftarrow$ extract the set of variables assigned $true$ in $model$ \\
    $M \leftarrow \bigcup_{a_i \in M} \actlit ^{-1}(a_i)$ \\
\BlankLine
    \If{$\isadeq (P, M)$}{
    \BlankLine
      $S' \leftarrow \getivc (P, M)$ \\
      $A \leftarrow A \cup S'$ \\
      $map \leftarrow map \wedge (\bigvee_{T_{i}\in S'} \neg {\actlit (T_i)})$
    }
    \Else{
      $map \leftarrow map \wedge (\bigvee_{T_{i}\in (T \setminus M)} \actlit (T_i))$ \\
    %  $L \leftarrow L \cup (\bigcup_{T_i \in C} T_i)$
    }
  }
  \Return{$A$}
\caption{Algorithm \aivcalg ~for computing $AIVC$}
\label{alg:aivc}
\end{algorithm}

\begin{theorem}
\label{theorem:aivc}
  Algorithm \ref{alg:aivc} enumerates all $MIS$es and $IVC$s.
\end{theorem}
\begin{proof}
In each iteration of the \texttt{while} loop, Algorithm \ref{alg:aivc} explores a set which is either a $MIS$ or leads to an $IVC$. These sets have not explored before according to Lemma \ref{lem:map:sound}. So, in each iteration a new minimal adequate or maximal inadequate member of $\mathcal {P}(T)$ is explored. Therefore, the loop continues as long as there is any $IVC$ or
$MIS$ not yet found.
\end{proof}


\begin{theorem}
\label{theorem:termination}
  Algorithm \ref{alg:aivc} will terminate.
\end{theorem}
\begin{proof}
The algorithm will terminate \emph{iff} $map$ eventually becomes  \unsat.
Based on Lemma \ref{lem:map:comp}, $map$ is \unsat \emph{iff} all
$IVC$s and $MIS$es have been explored.
So, following Theorem \ref{theorem:aivc},  Algorithm \ref{alg:aivc} will terminate.
\end{proof}



\input{minimality}
%\begin{algorithm}[t]
%  $k' \leftarrow 1$ \\
%  \While{$\checksat(\neg\iq_{k'}(T, P, P)) = \sat$} {
%    $k' \leftarrow k' + 1$ \\
%    }
%  \Return{$k'$} \\
%\caption{$\mink(T, P)$}
%\label{alg:minimize-k}
%\end{algorithm}


%\begin{theorem}
%\label{thm:minimal-hard}
%\end{theorem}
%\begin{proof}
%\end{proof}

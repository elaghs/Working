\section{Implementation}
\label{sec:impl}

To implement our method, we have made use of the technique proposed in \cite{Ghass16} for the efficient computation of IVCs.
In \cite{Ghass16}, there are two detailed algorithms for computing minimal IVCs: (1) Algorithm \ucbfalg that computes a truly minimal IVC for a given property, which is expensive. (2) Algorithm \ucalg that computes an IVC fairly close to minimal in a much more efficient way. This section provides a high-level representation of these algorithms.

IVCs are built upon inductive proofs. In order to prove a property, inductive proof methods employ some heuristics to derive additional lemmas (or invariants) about the problem so to strengthen the property and prove it inductively. Intuitively, to extract IVCs, Algorithm \ref{alg:uc}
first proves the property and obtains all the invariants generated for the proof (line 1). Since not all these invariants are essential for the proof, it performs some minimization to keep a minimal set of necessary invariants (line 2). The proofs of these invariants themselves are dependent on the structure of the model or design elements that we have defined them as inductive validity core (Definition \ref{def:ivc}).
So, using function $map\_to\_design$, Algorithm \ref{alg:uc}
computes those design elements. And finally, it minimizes the computed elements so to obtain a minimal IVC (line 4). Although Algorithm \ref{alg:uc} performs minimization, because of the structure of the inductive proofs, \ucalg might still not produce an \emph{exact} minimal IVC \footnote{\noindent ~for more information, see \cite{Ghass16}. Here we abstract away the details.}.
Therefore, Algorithm \ref{alg:ucbf}, \ucbfalg, includes a post-minimization process that
operates on the result of \ucalg. The results by this algorithm are guaranteed to be minimal.

Algorithm \ref{alg:must} is also an efficient way of computing the \emph{must} set of a given property using \ucalg. Note that, as discussed in Section \ref{sec:method}, the
output of \ucalg (as well as \ucbfalg) for $(I, T) \vdash P$ pinpoints the covered design elements
using \ivccov\ (Definition \ref{def:coverage-justi}).
And, the output of \mustalg represents covered design elements according to \nondetcov\ (Definition \ref{def:non-det}), which is the same as $MUST(P)$.

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$(I, T) \vdash P$}
  \Output{(Closely) minimal IVC for $(I, T) \vdash P$}
  \BlankLine
  $Invs \leftarrow get\_inductive\_invariants((I, T), P)$ \\
  $Invs \leftarrow minimize(Invs)$ \\
  $S \leftarrow map\_to\_design (T, Invs)$ \\
  $S \leftarrow minimize(S)$ \\
  \Return{S}
\caption{An abstract representation of \ucalg \cite{Ghass16}}
\label{alg:uc}
\end{algorithm}

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$(I, T) \vdash P$}
  \Output{Minimal IVC for $(I, T) \vdash P$}
  \BlankLine
  $S \leftarrow \ucalg((I, T) \vdash P)$ \\
  \For{$x \in S$} {
    \If{$(I, S\setminus\{x\}) \vdash P$}{
      $S \leftarrow S\setminus \{x\}$
    }
  }
  \Return{S}
\caption{An abstract representation of \ucbfalg \cite{Ghass16}}
\label{alg:ucbf}
\end{algorithm}


\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$(I, T) \vdash P$}
  \Output{Must set for $(I, T) \vdash P$}
  \BlankLine
  $S \leftarrow \ucalg((I, T) \vdash P)$ \\
  $M \leftarrow \varnothing$ \\
  \For{$x \in S$} {
    \If{$(I, S\setminus\{x\}) \nvdash P$}{
      $M = M \cup \{x\}$
    }
  }
  \Return{M}
\caption{\mustalg: an algorithm to compute $MUST(P)$ for a given $P$}
\label{alg:must}
\end{algorithm}

We have implemented the three algorithms introduced in this section in JKind \cite{jkind}, which is an infinite-state industrial model checker. JKind proves safety properties using multiple cooperative engines in parallel including k-induction \cite{SheeranSS00}, property directed reachability (PDR) \cite{Een2011:PDR}, and template-based lemma generation \cite{Kahsai2011}. It accepts
Lustre programs written over the theory of linear integer and real
arithmetic. In the back-end, it uses an SMT solver such as
Z3 \cite{DeMoura08:z3}, Yices \cite{Dutertre06:yices},
MathSAT \cite{Cimatti2013:MathSAT}, or SMTInterpol \cite{Christ2012:SMTInterpol}.
JKind works on multiple properties simultaneously. When a
property is proven and IVC generation is enabled, an additional
parallel engine executes Algorithm \ref{alg:uc} to generate a nearly minimal
IVC.

Although the minimality of $IVC$ sets makes \ivccov\ accurate
in terms of both preserving provability and not having false positives, the exact implementation of \ivccov\ is based on the \ucbfalg algorithm, which is as nearly expensive as the \mustalg algorithm for \nondetcov\ . To alleviate this issue, we have used the efficient implementation for \ivccov\ proposed in \cite{Ghass16}, i.e. \ucalg,
 which is an over-approximation and might not be always accurate in terms of minimality. In general, \nondetcov\ characterizes coverage in a way which is both expensive to compute and difficult to satisfy (i.e. it usually leads to low coverage scores). However, justifiable coverage is more efficient and practical to compute, which is also an immediate guidance of what is necessary for specification.

\subsection{Discussion}
As mentioned, IVCs are derived from inductive invariants; in other words, they are built upon the proof of the validity of a given property. One interesting fact about proofs
  is that a given property could be proved from different proof paths. That's why we defined $AIVC(P)$ in Section \ref{sec:background}. The $AIVC$ set gives a clear picture of various ways a property is satisfied. By getting all the IVCs for all the properties of the system and categorizing them, one can find if there are design artifacts that do not trace to any property: set $\bigcap \{IRR (P) | P \in \Delta \}$.  If this set is non-empty, it is a possible indication of ``gold plating" or missing properties. That is to say, it helps to assess if the specification describe all the behaviors of the system. Being able to measure the coverage of properties over the model is crucial in the safety critical system domain.

Very recent, as yet unpublished, work has focused on the
generation of all IVCs, whose preliminary evaluation
shows the overhead in discovering all IVCs is a linear in the
number of unique IVC in the problem multiplied by the cost
for finding a proof for a single IVC. For complex models, such
as the ones described in \cite {QFCS15:backes} and \cite{hilt2013}, it has been possible to
find $AIVC$ for individual properties in a matter of minutes.
Based on our preliminary results we expect computing $AIVC$ to be computationally feasible for complex models. In
addition, we believe that it is possible to use the information
from the set of all IVCs to more efficiently produce minimal
IVCs than the \ucbfalg algorithm. 
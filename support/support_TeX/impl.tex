\section{Implementation}
\label{sec:impl}

We have implemented the inductive validity core algorithms in the
previous section in two tools: {\em JKind}, which performs the \ucalg
algorithm, and {\em JSupport}, which can compute either the \bfalg or
the \ucbfalg algorithm (using JKind as a subprocess). Moreover, our
implementation of \ucbfalg uses an additional feature of JKind to
store and re-use discovered invariants between separate runs. This
reduces some of the cost of attempting to re-prove a property multiple
times. These tools operate over the Lustre
language~\cite{Halbwachs91:lustre}, which we briefly illustrate below.

\subsection{Lustre and IVCs}

\begin{figure}[t]
{\small
\begin{verbatim}
node main(x : int) returns (r : int; ok : bool);
let
  r = (0 -> pre r) + (if x > 0 then x else -x);
  ok = (r >= 0);
tel;
\end{verbatim}
}
  \caption{Example Lustre program}
  \label{fig:lustre-ex}
\end{figure}

Lustre~\cite{Halbwachs91:lustre} is a synchronous dataflow language
used as an input language for various model checkers. An example
Lustre program is shown in Figure~\ref{fig:lustre-ex}. For our
purposes, a Lustre program consists of 1) input variables, {\tt x} in
the example, 2) output variables, {\tt r} and {\tt ok} in the example,
and 3) an equation for each output variable. A Lustre program runs
over discrete time steps. On each step, the input variables take on
some values and are used to compute values for the output variables on
the same step. In addition, equations may refer to the previous value
of a variable using the {\tt pre} operator. This operator is
underspecified in the initial step, so the arrow operator, {\tt ->},
is used to guard the {\tt pre} operator. In the initial step the
expression {\tt e1 -> e2} reduces to {\tt e1}, and it reduces to {\tt
  e2} in all other steps.

We interpret a Lustre program as a model specification by considering
the behavior of the program under all possible input traces. Safety
properties over Lustre can then be expressed as Boolean output
variables in Lustre. A safety property holds if the corresponding
Boolean output variable is always true for all input traces. For
example, the program in Figure~\ref{fig:lustre-ex} represents an
integrator over the absolute value of the input variable. The output
variable {\tt ok} is a safety property of the system expressing that
the computed result is always non-negative. In this case, the property
is true.

It is easy to translate this interpretation of Lustre into the
traditional initial and transition relations. We will show this by
example using Figure~\ref{fig:lustre-ex}. First we introduce a new Boolean
variable $init$ into the state space to denote when the system is in
its initial step. Then we define,
\begin{align*}
  &I((x, r, \mathit{ok}, \mathit{init})) = \mathit{init} \\
  &T((x, r, \mathit{ok}, \mathit{init}), (x', r', \mathit{ok'},
  \mathit{init'})) = \\
  &\hspace{1cm} (r' = (\ite{init}{0}{r}) +~ \\
  &\hspace{1cm} \phantom{(r' =\,\,}(\ite{x'>0}{x'}{-x'})) \land~\\
  &\hspace{1cm} (\mathit{ok'} = (r' \geq 0)) \land \neg\mathit{init'}
\end{align*}
A safety property such as {\tt ok} is translated into $\mathit{init}
\lor \mathit{ok}$. Nested uses of arrow and pre operators are handled
by introducing new output variables for nested expressions, though
such details are unimportant for our purposes.

Each equation in the Lustre program is translated into a single
top-level conjunct in the transition relation. This is very convenient
as the IVC of a Lustre property can be reported in terms of the output
variables whose equations are part of the IVC. Equivalently, the
interpretation of an IVC for a Lustre property is that any output
variable that is not part of the IVC can be turned into an input
variable, its equation thrown away, while preserving the truth of the
property.

\subsection{JKind}

JKind is an infinite-state model checker for safety properties. JKind
proves safety properties using multiple cooperative engines in
parallel including $k$-induction, property directed reachability, and
template-based lemma generation. JKind accepts Lustre programs written
over the theory of linear integer and real arithmetic. In the back-end,
JKind uses an SMT-solver such as Yices, Z3, CVC4, MathSAT, or
SMTInterpol.

JKind works on multiple properties simulatenously. When a property is
proven and IVC generation is enabled, an additional parallel engine
executes Algorithm~\ref{alg:ivc} to generate a near-minimal IVC.

JKind accepts an annotation on its input Lustre program indicating
which outputs variables to consider for IVC generation. Output
variables not mentioned in the annotation are implicitly included in
all IVCs. This allows the implementation focus on the variables
important to the user and ignore, for example, administrative
equations. This is even more important for tools which generate Lustre
as they often create many such administrative equations which simply
wire together more interesting expressions.

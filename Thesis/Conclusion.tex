\chapter{Conclusions and Future Work}

In this thesis, we have introduced the idea of extracting a minimal IVC for a given property and its applications.  However, a single IVC often does not provide a complete picture of the traceability from a property to a model.  We have addressed the problem of extracting {\em all minimal} IVCs. Obtaining minimal IVCs for a given property is completely relevant to the problem of proving the correctness of that property. Since, in general, provability is undecidable, sometime engineers have to rely on bounded proofs. In order to utilize the IVC ideas in such cases, we have introduced the idea of bounded validity cores (BVCs).
We have shown
the correctness and completeness of our methods and algorithms.

We have implemented all of the inductive validity core algorithms in the JKind ~\cite{jkind} industrial model checker,
which verifies safety properties of infinite-state synchronous systems.
It accepts Lustre programs \cite{Halbwachs91:lustre} as input.  The translation of Lustre
into a symbolic transition system in JKind is straightforward and is similar to what is described
in~\cite{Hagen08:FMCAD}.
Verification is supported by multiple ``proof engines'' that execute in parallel, including $k$-induction,
property directed reachability (PDR), and lemma generation engines that attempt to prove
multiple properties in parallel.  To implement the engines,
JKind emits SMT problems using the theories of linear integer and real arithmetic. JKind supports the \texttt{Z3}, \texttt{Yices}, \texttt{MathSAT}, \texttt{SMTInterpol}, and \texttt{CVC4} SMT solvers as back-ends.  We extend JKind with new engines that implement our IVC generation algorithms. When a property is
proved and IVC generation is enabled, an additional parallel engine
executes one of the IVC algorithms.


In addition, we have performed a substantial evaluation that shows that the practicality and efficiency of our technique. For this purpose, we have collected a large set of benchmarks from different sources. Our experiments are conducted on a set of benchmarks containing 660 Lustre models, 530 from~\cite{Hagen08:FMCAD, piskac2016} and 130 industrial models derived from \cite{hilt2013} and other sources \cite{piskac2016, NFM2015:backes}.
 % Most of the academic benchmark models are small (10kB or less, with 6-40 equations) and include a range of hardware benchmarks and software problems involving counters that are difficult to solve inductively.
%The industrial models are much larger; for example, each 80 models from \cite{hilt2013} contain over 600 equations and are each $\geq$80kB in size. The benchmark includes 2 models from NASA Quad-redundant Flight Control System (QFCS)~\cite{NFM2015:backes}: the Flight Control System (FCS) with 5259 Lustre equations and the Flight Control Computer (FCC) with 10969 equations.

%We selected only benchmark problems consisting of a Lustre model with
%properties that JKind could prove with a 3-hour timeout.
%Experiments are run in a configuration with the \texttt{Z3} solver and the ``fastest'' mode of JKind (which involves running the $k$-induction and PDR engines in parallel and terminating when a solution is found). The experiments are expected to be run on an  Intel(R) i5-4690, 3.50GHz, 16 GB memory machine running Linux, and available online.

Our method for computing all MIVCs is inspired by a recent work in the domain of satisfiability analysis \cite{marco2016fast}. One interesting future direction is to devise similar MIVC enumeration algorithms based on other studies on MUSes extraction such as \cite{nadel2014accelerated}.
Another interesting direction for this project is to parallelize the enumeration process: it is certainly possible to ask for multiple distinct maximal models to be solved in parallel. 
A straight forward parallelization starts with computing one approximate IVC. Then \mustalg can be executed on one machine while several other engines are running the \aivcalg in parallel. The results of \mustalg shall be dispatched among the engines to expedite the process of exploring the map \footnote{see \ref{sec:offaivc}}.
%, though this may result in unnecessary work performed by some of the parallel solvers.

It is worthwhile to investigate additional applications of the idea.  When performing {\em compositional verification}, the All-IVCs technique may be able to determine {\em minimal component sets} within an architecture that can satisfy a given set of requirements, which may be helpful for design-space exploration and synthesis. In addition the approach can be used for robustness analysis; will system satisfy requirement $R$ even if a certain component fails? To answer this question, the All-IVCs analysis can tell us if the requirement is satisfied by different components independently. 


An study of the relationship between IVCs of the component-level and system-level properties itself is very interesting and can be useful; for example, in cases that the system property has only bounded proof, we can estimate/obtain its MIVCs without a proof. To do so, we need to map out an algorithm for extracting MIVCs of a system level property from the MIVCs of the component properties.

The granularity issue discussed in \ref{sec:disc} brings an important research question on how we can 

bvc other approaches

ivcs, first lemmas

proof

fault detection

optimization

testing code coverage

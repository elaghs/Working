\section{Implementation}
\label{sec:impl}

To implement our method, we have made use of the technique proposed in \cite{Ghass16} for the efficient computation of IVCs, which are the same as elements of a support set. In \cite{Ghass16}, there are two detailed algorithms for computing minimal support sets: (1) Algorithm \ucbfalg that computes a truly minimal support set for a given property, which is expensive. (2) Algorithm \ucalg that computes support sets fairly close to minimal much more efficiently. In this section, we provide a high-level representation of these algorithms. Intuitively, Algorithms \ref{alg:uc},
first obtains an inductive invariant from the inductive proof of
property $r$ (line 1 in Algorithm \ref{alg:uc}). Then, using function $map\_to\_design$, it
computes the (closely) minimal support set of $r$ \footnote{The way that support set
(or inductive validity cores) can be produced is described in \cite{Ghass16}. Here we abstract away the details.}.

Since \ucalg might not produce a truly minimal support set,
Algorithm \ref{alg:ucbf}, \ucbfalg, includes a minimization process that
operates on the result of \ucalg.

Algorithm \ref{alg:must} is also an efficient way of computing the \emph{must} set of a given property using \ucalg. Note that, as discussed in Section \ref{sec:method}, the
output of \ucalg (as well as \ucbfalg) for $\Gamma \vdash R$ pinpoints the covered design elements
based on Definition \ref{def:coverage-ivc}.
In other words, it is equal to
$C = \{\varphi | \varphi \in \Gamma \wedge  \psi_{sos} \preccurlyeq \varphi \}$.
And, the output of \mustalg represents covered design artifacts according to Definition \ref{def:coverage1}, which is the same as $C = \{\varphi | \varphi \in \Gamma \wedge \psi_{sm} \preccurlyeq \varphi \}$.

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$\Gamma \vdash r$}
  \Output{Support set for $\Gamma \vdash r$}
  \BlankLine
  $Inv \leftarrow get\_inductive\_invariant(\Gamma, r)$ \\
  $S \leftarrow map\_to\_design (\Gamma, Inv)$ \\
  \Return{S}
\caption{An abstract representation of \ucalg \cite{Ghass16}}
\label{alg:uc}
\end{algorithm}

We have implemented the three algorithms introduced in this section in JKind \cite{jkind}, which is an infinite-state model checker for safety properties. JKind proves safety properties using multiple cooperative engines in parallel including k-induction \cite{SheeranSS00}, property directed reachability \cite{Een2011:PDR}, and template-based lemma generation \cite{Kahsai2011}. JKind accepts
Lustre programs written over the theory of linear integer and real
arithmetic. In the back-end, JKind uses an SMT solver such as
Z3 \cite{DeMoura08:z3}, Yices \cite{Dutertre06:yices},
MathSAT \cite{Cimatti2013:MathSAT}, or SMTInterpol \cite{Christ2012:SMTInterpol}.
JKind works on multiple properties simultaneously. When a
property is proven and IVC generation is enabled, an additional
parallel engine executes Algorithm \ref{alg:uc} to generate a nearly minimal
IVC (or support) set.



\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$\Gamma \vdash r$}
  \Output{Minimal support set for $\Gamma \vdash r$}
  \BlankLine
  $S \leftarrow \ucalg(\Gamma \vdash r)$ \\
  \For{$x \in S$} {
    \If{$S\setminus\{x\} \vdash r$}{
      $S \leftarrow S\setminus \{x\}$
    }
  }
  \Return{S}
\caption{An abstract representation of \ucbfalg \cite{Ghass16}}
\label{alg:ucbf}
\end{algorithm}


\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{$\Gamma \vdash r$}
  \Output{Must set for $\Gamma \vdash r$}
  \BlankLine
  $S \leftarrow \ucalg(\Gamma \vdash r)$ \\
  $M \leftarrow \varnothing$ \\
  \For{$x \in S$} {
    \If{$S\setminus\{x\} \nvdash r$}{
      $M = M \cup \{x\}$
    }
  }
  \Return{M}
\caption{\mustalg: an algorithm to compute $MUST(r)$ for a given $r$}
\label{alg:must}
\end{algorithm} 